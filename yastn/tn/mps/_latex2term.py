# Copyright 2024 The YASTN Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
""" Interpretation of latex-like string into instrucitons further interpreted by YASTN. """

from typing import NamedTuple
from itertools import chain
import re

class GeneratorError(Exception):
    pass

basic_operation = ["+", "*"]

class single_term(NamedTuple):
    """
    Helper object.

    Contains the elements of a product without differentiating
    the operator from a number.

    Format of the output of latex2term
    """
    op: tuple = ()

def get_variable(var):
    """
    Helper function.

    Extract name of the variable from the index from a string.

    Parameters
    ----------
    var: str
        Required format is e.g., a_{i,j,k}, where a-is a name of the object,
        and i,j,k is a list of indicies separated by commas, with no spaces.
        Indicies can be given in format as used in Generator's _map.
    """
    m = re.match(r'(.*)_{(.*)}', var)
    return (var,) if not m else (m.group(1), *m.group(2).split(","))

def issingle_term(d):
    """
    Helper function.

    Checks if the element is in the final format or should be further extracted.
    """
    if isinstance(d, single_term):
        return True
    elif isinstance(d, list):
        return all([issingle_term(x) for x in d])
    else:
        return False

def replace_index(single_term_el, old_name, new_name):
    """
    Helper function.

    Replace symbolic index by an index generated by the iterator.

    Parameters
    ----------
    single_term_el: single_term
        Input single_term object with dummy indicies for iterator.
    old_name, new_name: list or tuple
        old_name is a set indexed with iterator symbols, new_name is
        a set of indicies generater by the iterator.
    """
    old_name = old_name
    new_name = [new_name] if len(old_name)==1 else new_name
    if len(old_name) != len(new_name):
        raise GeneratorError("Number of old and new indicies is not consistent.")
    new_op = []
    for op in single_term_el.op:
        for jold, jnew in zip(old_name, new_name):
            op = tuple([jnew if ind == jold else ind for ind in op])
        new_op += (op,)
    return single_term(op=tuple(new_op))

def combine_lists(operation, list1, list2, gen_param):
    """
    Helper function.

    Defines an action of basic_operation-s on list of single_term-s.

    Parameters
    ----------
    operation: str
        operation from basic_operation
    list1, list2: list
        One dimensional lists of single_term-s.
    gen_param: dict
        Dictionary for the interpreter.
    """
    if operation == "+":
        return list1 + list2
    elif operation == "*":
        new_list = []
        for n in list1:
            for m in list2:
                new_list.append(apply_operation(operation, [n, m], gen_param))
        return new_list

def apply_operation(operation, single_terms, gen_param):
    """
    Helper function.

    Defines an action of basic_operation-s on single_term-s.

    Parameters
    ----------
    operation: str
        operation from basic_operation
    single_terms: list
        One dimensional list of single_term-s.
    gen_param: dict
        Dictionary for the interpreter.
    """
    if operation == "+":
        return single_terms
    elif operation == "*":
        new_op = ()
        for x in single_terms:
            new_op = new_op+x.op
        return single_term(op=new_op)
    elif operation[0] == "sum":
        # iterate over list read from gen_param parameters
        m = re.match(r'{(.*).in.(.*)}', operation[1])
        iterator, iterate_list = (m.group(1).split(",")), m.group(2)
        sum_elements = []
        for new_iterator in gen_param[iterate_list]:
            for new_list in single_terms.copy():
                sum_elements.append(replace_index(new_list, iterator, new_iterator))
        return sum_elements

def interpret(c, gen_param):
    """
    Interprets the instruction for generating single-term-s as provided by
    splitt() function here.

    Parameters
    ----------
    c: tuple
        Intruction generated by split()
    gen_param: dict
        Dictionary for the interpreter.
    """
    # Terminate if you have a list of single_term-s
    if all([isinstance(x, single_term) for x in c]):
        return c
    # Instruction is given by a tuple with operation as first element
    # and list of elements it connects as second
    # e.g., (operation, list of elements)
    operation, elements = c
    if isinstance(operation, tuple):
        # For iterating operation
        if issingle_term(elements):
            # Apply operation
            return apply_operation(operation, elements, gen_param)
        else:
            # Expand elements to simple list before iterating
            return (operation, interpret(elements, gen_param))
    elif operation in basic_operation:
        # Use basic operations
        if all([isinstance(x, single_term) for x in elements]):
            # for simple list of single_terms combine_single_terms using single_term algebra
            return apply_operation(operation, elements, gen_param)
        if all([issingle_term(x) for x in elements]):
            el_me = elements
            if operation == "+":
                return interpret(tuple([operation, list(chain(*el_me))]), gen_param)
            elif operation == "*":
                initial = el_me[0]
                for n in range(1, len(el_me)):
                    initial = combine_lists(operation, initial, el_me[n], gen_param)
                return initial
        else:
            # so elements are still embedded and there are other single_term interpreter-s needed
            return interpret(tuple([operation, list(map(lambda x: interpret(x, gen_param), elements))]), gen_param)

def splitt(b, eq_it):
    """
    Reads list of strings and interprets latex-like format of the intruction.
    The function generates an instruction for interpreter() function here
    by applying the order of operations in latex-like format.

    Parameters
    ----------
    b: str
        string in latex-like format
    eq_it: int
        Split the intruction in b with respect to the operation basic_operation[eq_it]
    """
    if not b or eq_it > len(basic_operation):
        raise GeneratorError("Not supported. You provided an empty list or there is no such basic operation.")
    # split against that operation
    operation = basic_operation[eq_it]
    # check brackets
    id_start = [i for i, x in enumerate(b) if x == "("]
    id_stop = [i for i, x in enumerate(b) if x == ")"]
    if len(id_start) != len(id_stop):
        raise GeneratorError("Inconsistent brackets!")
    # check sums
    id_startX = [i for i, x in enumerate(b) if x == "sum"]
    id_stopX = [i for i, x in enumerate(b) if x == "endsum"]
    if len(id_startX) and len(id_startX) == len(id_stopX):
        # remove those we don't need
        if id_startX[0] == 0 and id_stopX[-1] == len(b)-1:
            is_bad = False
            res = 0
            tmp = b[1:-1]
            for n in tmp:
                if n == 'sum':
                    res += 1
                elif n == 'endsum':
                    res -= 1
                if res < 0:
                    is_bad = True
                    break
            if not is_bad:
                in_sum = tmp[1:] if len(tmp) > 2 else tmp[1]
                return ("sum", tmp[0]), splitt(in_sum, 0)

    # Check if there are any basic operations
    # If a single string gen_paramerate single_term
    #if not isinstance(b, list) or len(b) == 1:
    #    # Ends recursion.
    #    op = (get_variable(b),) if isinstance(b, str) else (get_variable(b[0]),)
    #    return [single_term(op=op)]

    id_basic_operation = [i for i, x in enumerate(b) if x in basic_operation]
    if not "sum" in b and not id_basic_operation and '(' not in b:
        # There is no recognized operation between objects. Assume it is a multiplication.
        op = tuple([get_variable(ib) for ib in b]) if isinstance(b, list) else (get_variable(b),)
        return [single_term(op=op)]

    # Main splitter loop
    n, bracket_open, sum_open = 0, 0, 0
    # tunnel - list of elements connected by the operation
    # buffer - collects pieces of elements pushed into tunnel
    tunnel, buffer = [], []
    for n in range(len(b)):
        sig = b[n]

        # Brackets have higher rank than basic_operation
        if sig == '(':
            bracket_open += 1
        elif sig == ')':
            bracket_open -= 1

        # Itarative operations have higher rank than basic_operation and brackets
        if bracket_open == 0 and sig == "sum":
            sum_open += 1
        if sig == "endsum":
            sum_open -= 1
        if bracket_open == 0 and sum_open > 0 and sig == "+":
            # Addition outside all brackets ends sums
            [buffer.append("endsum") for _ in range(sum_open)]
            sum_open = 0
        # Control buffer/tunnel flow
        tunnel_closed = (sig not in operation or bracket_open!=0) or sum_open > 0
        if tunnel_closed:
            if operation == "*" and (sig =='(' and bracket_open == 1):
                if len(buffer) == 1:
                    tunnel.append(*buffer)
                else:
                    if buffer:
                        tunnel += [buffer]
                buffer = []
            elif operation == "*" and (sig == ')' and bracket_open == 0):
                if buffer:
                    tunnel += [buffer]
                buffer = []
            else:
                buffer.append(sig)
        else:
            if len(buffer) == 1:
                tunnel.append(*buffer)
            else:
                if buffer:
                    tunnel += [buffer]
            buffer = []
            tunnel_closed = False
    [buffer.append("endsum") for _ in range(sum_open)]
    if len(buffer) == 1:
        tunnel.append(*buffer)
    else:
        if buffer:
            tunnel += [buffer]
    # Apply interpreter to all elements separated by the operation
    return operation, list(map(lambda x: splitt(x, (eq_it + 1)%len(basic_operation)), tunnel))

def string2list(c0):
    """
    Helper function.

    Take the latex-like intruction in a form of a string and put in an input format
    for split() function.

    Parameters
    ----------
    c0: str
        String with latex-like intstuction.

    Notes
    ----------
        Interpret "+" as summation.

        Interpret "-" as summattion with a multiplication by (-1).

        Interpret "*" and a space as multiplication.

        Interpret summation in a format e.g., "\sum_{i,j \in A}" or "sum_{i,j \in A}".

        Interpret "(" ")" as brackets. Only round brackets are supported.
    """
    if not c0:
        return []
    else:
        # replace muiltiple spaces with a single space
        c0 = c0.replace("-", " + minus * ")
        c0 = c0.replace("\sum_", " sum ")
        for ix in ["+","*","(",")"]:
            c0 = c0.replace(ix, " "+ix+" ")
        c0 = " ".join(c0.split())
        c0 = c0.replace(" \in", "\in").replace("\in ", "\in")
        c0 = c0.replace("\in", ".in.")
        return c0.split(" ")


def latex2term(c0, param_dict):
    """
    Main function.

    Takes the latex-like intruction in a form of a string and puts it into a list of
    single_term-s.

    Parameters
    ----------
    c0: str
        String with latex-like intstuction.
    param_dict: dict
        Dictionary with parameters for the generator.

    Notes
    ----------
        Applies the function in this file in order to perform extraction.
        For more detail see the functions in this file.
    """
    return interpret(splitt(string2list(c0), 0), param_dict.copy())
